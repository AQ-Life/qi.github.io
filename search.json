[
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference",
    "section": "",
    "text": "Markdown 官方教程\nR Markdown Cookbook\nCreating Websites with R Markdown\nR Quarto"
  },
  {
    "objectID": "reference.html#markdown",
    "href": "reference.html#markdown",
    "title": "Reference",
    "section": "",
    "text": "Markdown 官方教程\nR Markdown Cookbook\nCreating Websites with R Markdown\nR Quarto"
  },
  {
    "objectID": "reference.html#r",
    "href": "reference.html#r",
    "title": "Reference",
    "section": "R",
    "text": "R\n\nCookbook-for-R-Chinese"
  },
  {
    "objectID": "Qblog/2023/sas-heart/index.html",
    "href": "Qblog/2023/sas-heart/index.html",
    "title": "SAS 绘制动态爱心",
    "section": "",
    "text": "五一过后，也预示着520也快来了，又到了想破脑袋送礼物的时候了。SAS programmer 该如何表达自己的浪漫，这次我们利用SAS来绘制一颗动态的爱心。"
  },
  {
    "objectID": "Qblog/2023/sas-heart/index.html#准备数据",
    "href": "Qblog/2023/sas-heart/index.html#准备数据",
    "title": "SAS 绘制动态爱心",
    "section": "准备数据",
    "text": "准备数据\n下面绘制心形曲线的函数是来源于广大的网友，我们再按照函数生成一系列的模拟数据。\ndata heart;\n    pi=constant('PI');\n    do t=0 to 65 by 100/400;\n        x = -.01*(-t**2+35*t+1950)*sin(pi*t/180);\n        y = .01*(-t**2+35*t+1950)*cos(pi*t/180);\n    output;\n    x=-x;\n    output;\n    end;\nrun;"
  },
  {
    "objectID": "Qblog/2023/sas-heart/index.html#定制gtl-template",
    "href": "Qblog/2023/sas-heart/index.html#定制gtl-template",
    "title": "SAS 绘制动态爱心",
    "section": "定制GTL template",
    "text": "定制GTL template\n常见的是scatterplot绘制散点图，来描绘心形曲线。\nods path(prepend) work.templat(update);\n\nproc template;\ndefine statgraph sgdesign;\nbegingraph / border=false;\n   layout overlay / walldisplay=(fill) xaxisopts=( linearopts=( viewmin=-12 viewmax=12) display=none) yaxisopts=( linearopts=( viewmin=0 viewmax=22.0) display=none);\n        scatterplot x=x y=y / markerattrs=(color=red symbol=circlefilled );\n   endlayout;\nendgraph;\nend;\nrun;"
  },
  {
    "objectID": "Qblog/2023/sas-heart/index.html#绘制动态爱心曲线",
    "href": "Qblog/2023/sas-heart/index.html#绘制动态爱心曲线",
    "title": "SAS 绘制动态爱心",
    "section": "绘制动态爱心曲线",
    "text": "绘制动态爱心曲线\nSAS绘制动态曲线，主要是通过options animate=start;与options animate=stop; 这里的动态图就是多张静态图汇集而成的，我们再通过控制帧数等参数达到动态图的效果。\ntitle; footnote;\noptions noxwait missing='';\noptions printerpath=gif nonumber nodate animduration=0.001 animloop=yes nobyline;\noptions animate=start;\n\nods printer;\n\n%macro aa;\n    %do i=1 %to 65;\n        proc sgrender data=heart template=sgdesign;\n            where t&lt;=&i.;\n        run;\n    %end;\n%mend;\n%aa;\n\nods printer close;\noptions animate=stop;"
  },
  {
    "objectID": "Qblog/2023/r-gmt-plot/index.html",
    "href": "Qblog/2023/r-gmt-plot/index.html",
    "title": "R 输出GMT plot",
    "section": "",
    "text": "library(plyr)\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(scales)\n\nadis &lt;- read_sas(\"adis.sas7bdat\")\n\nadis1 &lt;- adis %&gt;% \n  filter(IPPSFL == \"Y\", PARAMCD == \"SAR2NAB\", ANL01FL == \"Y\", COHORT == \"Cohort 2\") %&gt;% \n  mutate(TPTN = case_when(AVISITN == 0 ~ 1+(TRTAN-1)*2,\n                          AVISITN %in% c(28, 42) ~ 2+(TRTAN-1)*2,\n                          AVISITN %in% c(120, 150) ~ 3+(TRTAN-1)*2,\n                          AVISITN %in% c(148, 178) ~ 4+(TRTAN-1)*2),\n         LOGAVAL = log10(AVAL),\n         LOGFOLD = log10(AVAL/BASE)\n           ) \n\nmean1 &lt;- adis1 %&gt;% \n  group_by(TRTAN, TPTN, AVISITN) %&gt;% \n  select(TRTAN, TPTN, AVISITN, LOGAVAL, LOGFOLD) %&gt;% \n  dplyr::summarise(n = n(),\n            mean1 = mean(LOGAVAL),\n            mean2 = mean(LOGFOLD),\n            sd1 = sd(LOGAVAL),\n            sd2 = sd(LOGFOLD)) %&gt;% \n  mutate(se = sd1/sqrt(n),\n         lclm = mean1 - 1.96 * se,\n         uclm = mean1 + 1.96 * se,\n         yerrl = 10**lclm,\n         yerru = 10**uclm,\n         means = 10**mean1,\n         foldmean = ifelse(AVISITN != 0,10**mean2, NA),\n         nlabel = str_c(\"(N=\",as.character(n),\")\"),\n         foldlabel = str_c(as.character(round(foldmean,1)),\"x\"),\n         ymin = 10^5*1.5,\n         ymax = 10^5*2)\n\nfinal &lt;- rbind.fill(adis1, mean1)\n\n\nggplot(final) +\n  geom_col(aes(x = TPTN, y = means, fill = factor(TRTAN)), alpha = 0.3, na.rm = TRUE)+\n  geom_jitter(aes(x = TPTN, y = AVAL, color = factor(TRTAN)), na.rm = TRUE)+\n  geom_errorbar(aes(x = TPTN, ymin = yerrl, ymax = yerru), width = .5, size = 0.5)+\n  geom_text(aes(x = TPTN, y = 10^5, label = as.character(round(means))), na.rm = TRUE, family = \"WRYH\", fontface = \"bold\", size = 4)+\n  geom_text(aes(x = TPTN, y = 0.25, label = nlabel), na.rm = TRUE, family = \"WRYH\", fontface = \"bold\", size = 4)+\n  geom_text(aes(x = TPTN - 0.5, y = 10^5*3, label = foldlabel), na.rm = TRUE, family = \"WRYH\", fontface = \"bold\", size = 4)+\n  geom_linerange(aes(x = TPTN, ymin = ymin, ymax = ymax), na.rm = TRUE)+\n  geom_linerange(aes(xmin = 1, xmax = 2, y = 10^5*2))+\n  geom_linerange(aes(xmin = 3, xmax = 4, y = 10^5*2))+\n  geom_linerange(aes(xmin = TPTN - 0.1, xmax = TPTN + 0.1, y = means), linewidth = 0.5, na.rm = TRUE)+\n  geom_vline(xintercept = 2.5, linetype = \"f8\", alpha = 0.4)+\n  theme_classic()+\n  annotation_logticks(sides = \"l\")+\n  scale_y_log10(breaks = 10^(0:5),\n               #labels=trans_format(\"log10\", math_format(10^.x)),\n               label = c(expression(bold(\"10\"^\"0\")), expression(bold(\"10\"^\"1\")), expression(bold(\"10\"^\"2\")), expression(bold(\"10\"^\"3\")), expression(bold(\"10\"^\"4\")), expression(bold(\"10\"^\"5\"))),\n               expand = c(0, 0))+\n  scale_x_continuous(breaks = seq(1, 4, by = 1),\n                     labels = c(\"D0 \", \"D28\", \"D0 \", \"D28\"))+\n  labs(y = \"PRNT50 Titer\", x = NULL)+\n  scale_fill_manual(values = c(\"grey\", \"blue\"),\n                    guide = \"none\")+\n  scale_color_manual(values = c(\"grey\", \"blue\"),\n                    label = c(\"SCTV01E\", \"SCTV01E-1\")) +\n  theme(legend.title = element_blank(),\n        panel.grid = element_blank(),\n        text = element_text(family = \"WRYH\", \n                            face = \"bold\",\n                            color = \"black\",\n                            size = 12),\n        axis.text = element_text(family = \"ArialUnicode\",\n                                 face = \"bold\",\n                                 color = \"black\",\n                                 size = 12),\n        line = element_line(color = \"black\"),\n        plot.margin = unit(c(2,0,1,0.5),\"lines\")\n        )+\n  coord_cartesian(ylim = c(1, 100000),\n                  clip = \"off\")"
  },
  {
    "objectID": "Qblog/2021/vs-domain.html",
    "href": "Qblog/2021/vs-domain.html",
    "title": "VS Domain",
    "section": "",
    "text": "VS 是 findings domain，主要包含了血压、体温、呼吸、脉搏、身高、体重等检查结果。\n\n\n-‌-TEST 是 findings domain 的标志。 生命体征检查项和简称都有 Terminology，比如常见的 - SYSBP = Systolic Blood Pressure - DIABP = Diastolic Blood Pressure - PULSE = Pulse Rate - RESP = Respiratory Rate - TEMP = Temperature - HEIGHT = Height - WEIGHT = Weight - INTP = Interpretation\n国内一些试验习惯将身高体重放置在 CRF Demographic 页面，但我们在注释CRF的时候应该注意要将其注释到 VS domain.\n\n\n\n体位的收集在有些时候十分有必要，受试者由于特殊情况，可能导致无法坐立，只能躺着，而其他受试者坐立，此时两者的血压差异并不能作为后续分析时判断的依据。\n\n\n\n-‌-ORRES 是收集到的原始结果，-‌-ORRESU 是原始结果的单位，需要注意 -‌-ORRESU 是有 Terminology，那么如果EDC中未设置好标准术语的单位，需要对其进行转换。比如EDC中单位是 “s”，表示秒，需要将其转换为 “sec”，以满足数据递交的标准。\n\n\n\n这组变量强调的是在标准单位下的字符型或数值型结果。表示结果的 -‌-ORRES，-‌-STRESC，-‌-STRESN 这三个变量的衍生顺序为： -‌-ORRES -‌-&gt; -‌-STRESC -‌-&gt; -‌-STRESN 当 -‌-STRESC -‌-&gt; -‌-STRESN 无法进行转换时，-‌-STRESN 为missing，比如： |-‌-ORRES|-‌-STRESC|-‌-STRESN| |:–|:–|:–| |&lt;100|&lt;100|.|\n如果原始单位与标准单位不一致，就会存在相应的转换关系，特别是在 LB Domain 中会经常碰到，需要注意 -‌-ORRES -‌-&gt; -‌-STRESC 的转换。比如从原始单位转换为标准单位需要乘以10，\n\n\n\n-‌-ORRES\n-‌-STRESC\n-‌-STRESN\n\n\n\n\n&lt;100\n&lt;1000\n.\n\n\n\n可以看到我们需要将 -‌-ORRES 中的100*10之后再保留&lt;，放置在 -‌-STRESC中。\n\n\n\n当检查项未做时，需要衍生这一组 -‌-STAT/-‌-REASND 变量。\n\n\n\n-‌-LOBXFL是 SDTM IG 3.3 新增的变量，定义为用药前的最后一条非缺失记录，可能大家会认为该定义似乎和 - -BLFL 一样，认为基线也是定义为用药前的最后一条非缺失记录。 那么在临床试验中，的确是很多临床试验都将基线定义为用药钱的最后一条非缺失记录，但也存在一些特殊情况。比如可能选择对某一指标每隔1h连续三次检测，将三次结果的平均值作为基线，也是可以的。"
  },
  {
    "objectID": "Qblog/2021/vs-domain.html#vs-vital-signs生命体征",
    "href": "Qblog/2021/vs-domain.html#vs-vital-signs生命体征",
    "title": "VS Domain",
    "section": "",
    "text": "VS 是 findings domain，主要包含了血压、体温、呼吸、脉搏、身高、体重等检查结果。\n\n\n-‌-TEST 是 findings domain 的标志。 生命体征检查项和简称都有 Terminology，比如常见的 - SYSBP = Systolic Blood Pressure - DIABP = Diastolic Blood Pressure - PULSE = Pulse Rate - RESP = Respiratory Rate - TEMP = Temperature - HEIGHT = Height - WEIGHT = Weight - INTP = Interpretation\n国内一些试验习惯将身高体重放置在 CRF Demographic 页面，但我们在注释CRF的时候应该注意要将其注释到 VS domain.\n\n\n\n体位的收集在有些时候十分有必要，受试者由于特殊情况，可能导致无法坐立，只能躺着，而其他受试者坐立，此时两者的血压差异并不能作为后续分析时判断的依据。\n\n\n\n-‌-ORRES 是收集到的原始结果，-‌-ORRESU 是原始结果的单位，需要注意 -‌-ORRESU 是有 Terminology，那么如果EDC中未设置好标准术语的单位，需要对其进行转换。比如EDC中单位是 “s”，表示秒，需要将其转换为 “sec”，以满足数据递交的标准。\n\n\n\n这组变量强调的是在标准单位下的字符型或数值型结果。表示结果的 -‌-ORRES，-‌-STRESC，-‌-STRESN 这三个变量的衍生顺序为： -‌-ORRES -‌-&gt; -‌-STRESC -‌-&gt; -‌-STRESN 当 -‌-STRESC -‌-&gt; -‌-STRESN 无法进行转换时，-‌-STRESN 为missing，比如： |-‌-ORRES|-‌-STRESC|-‌-STRESN| |:–|:–|:–| |&lt;100|&lt;100|.|\n如果原始单位与标准单位不一致，就会存在相应的转换关系，特别是在 LB Domain 中会经常碰到，需要注意 -‌-ORRES -‌-&gt; -‌-STRESC 的转换。比如从原始单位转换为标准单位需要乘以10，\n\n\n\n-‌-ORRES\n-‌-STRESC\n-‌-STRESN\n\n\n\n\n&lt;100\n&lt;1000\n.\n\n\n\n可以看到我们需要将 -‌-ORRES 中的100*10之后再保留&lt;，放置在 -‌-STRESC中。\n\n\n\n当检查项未做时，需要衍生这一组 -‌-STAT/-‌-REASND 变量。\n\n\n\n-‌-LOBXFL是 SDTM IG 3.3 新增的变量，定义为用药前的最后一条非缺失记录，可能大家会认为该定义似乎和 - -BLFL 一样，认为基线也是定义为用药前的最后一条非缺失记录。 那么在临床试验中，的确是很多临床试验都将基线定义为用药钱的最后一条非缺失记录，但也存在一些特殊情况。比如可能选择对某一指标每隔1h连续三次检测，将三次结果的平均值作为基线，也是可以的。"
  },
  {
    "objectID": "Qblog/2021/sas-sql-2/index.html",
    "href": "Qblog/2021/sas-sql-2/index.html",
    "title": "SAS SQL（二）：横向合并的逻辑",
    "section": "",
    "text": "学习SAS语法，需要进行数据集的横向合并，首先接触到的都是 Merge 语句，常见用法如下。\ndata combine_dataset;\n    merge dataset1 dataset2;\n    by key_variable;\nrun;\n那么使用SAS SQL同样也可以进行横向合并。 使用 DATA Step 的 merge 语句横向合并，是基于 PDV，逐行读取、匹配、输出观测，而 SAS SQL 的逻辑则不同。 在 SAS SQL（一）：语法顺序与执行顺序 中提到 SQL 语句的 FROM 是首先执行的语句，而在 FROM 语句执行的过程中，可以认为还有三个步骤。 1. cartesian product，笛卡尔积 2. on，on 用于 key variable 匹配 3. outerjoin，外部连接\n我们运行如下程序。\ndata dataset1;\n    input id1 $ score1;\n    cards;\n    001 98\n    002 91\n    005 81\n    ;\nrun;\n\ndata dataset2;\n    input id2 $ score2;\n    cards;\n    002 87\n    003 94\n    005 79\n    006 77\n    ;\nrun;\n\nproc sql;\n    select coalescec(a.id1, b.id2) as id, \n            score1, \n            score2 \n        from dataset1 a \n        full join dataset2 b \n        on a.id1=b.id2;\nquit;\n得到结果如图。\n\n\n\nresult\n\n\n采用的是 full join 的连接方式，但最终结果是5条观测，按照上面 FROM 语句的三个步骤。 1. 形成笛卡尔积，一共是12条观测。 2. on，通过 id1，id2 两个 variable 进行匹配，保留下来的是2条观测 3. outer join 是 full join，那么既要保留 dataset1 中没有匹配上的观测（1条观测）和 dataset2 中没有匹配上的观测（2条观测）\n所以最终得到的结果就是 2+1+2=5 条观测。"
  },
  {
    "objectID": "Qblog/2021/sas-flow-chart/index.html",
    "href": "Qblog/2021/sas-flow-chart/index.html",
    "title": "SAS绘制流程图",
    "section": "",
    "text": "流程图\n\n\nCSR中的第一张表格往往会是一张流程图，那么使用SAS如何绘制流程图，我们一起来看看。\nSAS ANNOTATION FUNCTIONS:\n%annomac;\n\n\n\n\n\n\n\nMacro to use\nTasks\n\n\n\n\n%ARROW(x1, y1, x2, y2, color, line, size, angle, style);\nDraw an arrow\n\n\n%RECT(x 1,y 1,x 2,y 2, color, line, size);\nDraw a rectangle\n\n\n%LABEL(x, y, text, color, angle, rotate, size, style, position);\nDraw text\n\n\n\n%ARROW(x1, y1, x2, y2, color, line, size, angle, style); Function: Draws an arrow from (X1, Y1) to (X2,Y2). Parameter line: specifies the length of the sides of the arrowhead \nsize: specifies the width of the line \nangle: specifies the angle of the tip of the arrowhead\nstyle:specifies the type of arrowhead \n%RECT(x 1,y 1,x 2,y 2, color, line, size); Function: Draws a rectangle with diagonal corners at two specified points. Parameters\nline: specifies the rectangle’s line type\n\n\n\narrow\n\n\n%LABEL(x, y, text, color, angle, rotate, size, style, position); Function: Places a text label at the specified coordinates Parameters angle: specifies the angle of the text string with respect to the horizontal rotate: specifies the rotation angle of each character in the text string size: specifies the size of the text string style: specifies the text font position: specifies the placement and alignment\n\n\n\nposition\n\n\n%macro add_element(x=,y=,width=,height=,text=);\n %rect(&x,&y,&x+&width,&y+&height,black,1,1);\n %let i=1;\n %do %until (%qscan(&text,&i,'|')=);\n %label(&x+1,&y+&height-2*&i,\"%qscan(&text,&i,'|')\",BLACK,0,0,1.5,SimSun,6);\n %let i=%eval(&i+1);\n %end;\n%mend add_element; \n\n\ndata final;\n length function color style $8. text $60.;\n retain xsys '3' ysys '3' hsys '3' when 'a' line 1 function 'label';\n\n %add_element(x=10,y=83,width=20,height=15,text=%str( 5mg/kg | 筛选入组&scrn1.人 | 筛选失败&scrnf1.人 | 随机&rand1.人 | 治疗&treat1.人 | 退出研究&disc1.人 ));\n %add_element(x=50,y=92,width=20,height=8,text=%str( 试验组（N=&n1.）| 治疗&t1.人 | 退出研究&d1.人 ));\n %add_element(x=50,y=83,width=20,height=8,text=%str( 安慰剂组（N=&n2.）| 治疗&t2.人 | 退出研究&d2.人 ));\n\n %add_element(x=10,y=63,width=20,height=15,text=%str( 15mg/kg | 筛选入组&scrn2.人 | 筛选失败&scrnf2.人 | 随机&rand2.人 | 治疗&treat2.人 | 退出研究&disc2.人 ));\n %add_element(x=50,y=72,width=20,height=8,text=%str( 试验组（N=&n3.）| 治疗&t3.人 | 退出研究&d3.人 ));\n %add_element(x=50,y=63,width=20,height=8,text=%str( 安慰剂组（N=&n4.）| 治疗&t4.人 | 退出研究&d4.人 ));\n\n %add_element(x=10,y=44,width=20,height=15,text=%str( 30 mg/kg | 筛选入组&scrn3.人 | 筛选失败&scrnf3.人 | 随机&rand3.人 | 治疗&treat3.人 | 退出研究&disc3.人 ));\n %add_element(x=50,y=53,width=20,height=8,text=%str( 试验组（N=&n5.）| 治疗&t5.人 | 退出研究&d5.人 ));\n %add_element(x=50,y=44,width=20,height=8,text=%str( 安慰剂组（N=&n6.）| 治疗&t6.人 | 退出研究&d6.人 ));\n\n %add_element(x=10,y=25,width=20,height=15,text=%str( 50mg/kg | 筛选入组&scrn4.人 | 筛选失败&scrnf4.人 | 随机&rand4.人 | 治疗&treat4.人 | 退出研究&disc4.人 ));\n %add_element(x=50,y=34,width=20,height=8,text=%str( 试验组（N=&n7.）| 治疗&t7.人 | 退出研究&d7.人 ));\n %add_element(x=50,y=25,width=20,height=8,text=%str( 安慰剂组（N=&n8.）| 治疗&t8.人 | 退出研究&d8.人 ));\n\n /*** CONNECTING LINES... ***/\n %arrow(20,83,20,78,BLACK,1,0.1,90,filled);\n %arrow(20,63,20,59,BLACK,1,0.1,90,filled);\n %arrow(20,44,20,40,BLACK,1,0.1,90,filled);\n\n %arrow(30,90.5,50,96,BLACK,1,0.1,90,filled);\n %arrow(30,90.5,50,87,BLACK,1,0.1,90,filled);\n\n %arrow(30,70.5,50,76,BLACK,1,0.1,90,filled);\n %arrow(30,70.5,50,67,BLACK,1,0.1,90,filled);\n\n %arrow(30,51.5,50,57,BLACK,1,0.1,90,filled);\n %arrow(30,51.5,50,48,BLACK,1,0.1,90,filled);\n\n %arrow(30,32.5,50,38,BLACK,1,0.1,90,filled);\n %arrow(30,32.5,50,29,BLACK,1,0.1,90,filled);\n\nrun;\n\n/******\nretain xsys '3' ysys '3' hsys '3’;\nspecify graphics output area\n******/\n\n/* displays Annotate graphics */\nproc gslide annotate=final;\nquit;\n最后看一下我们输出的流程图。 \n从上面的代码中可以看出，我们需要标记清楚每一个点的坐标，但是这样无疑是很复杂的，所以SAS虽然可以实现绘制流程图，但是并不建议临床项目当中使用SAS来绘制。"
  },
  {
    "objectID": "Qblog/2021/data-step-tranpose.html",
    "href": "Qblog/2021/data-step-tranpose.html",
    "title": "Data Step 转置",
    "section": "",
    "text": "SAS Programming 中想到转置，可能都会知道 Transpose Procdure，比如有一份每个人的三次评分数据，需要进行转置。\ndata score1;\n    input name $ score1 score2 score3;\n    datalines\n    ;\n    lisa 100 92 .\n    bill 89 80 83\n    iris 77 . .\n    ;\nrun;\n\nproc sort data=score1;\n    by name;\n    run;\n\nproc transpose data=score1 out=score1_tran1(drop=_name_) prefix=col;\n    by name;\n    var score1 score2 score3;\nrun;\n\n这种方法想必大家已经熟知，那么在 Data Step 该如何进行转置，其实就是十分强大的 Do & Array 工具。\ndata score1_tran2(drop=i score1-score3);\n    set score1;\n    array ary score1-score3;\n    do i=1 to dim(ary);\n        score=ary(i);\n        output;\n    end;\nrun;\n可以实现和 transpose 同样的结果，当然也可以再转置回来。\ndata score1_tran3(drop=i score);\n    array ary score1-score3;\n    do i=1 to dim(ary);\n        set score_tran2;\n        ary(i)=score;\n    end;\nrun;\n利用 Do & Array 实现转置的强大功能体现在于下面的示例，比如有一份数据如下。\ndata score2;\n    input name $ level score mean ;\n    datalines\n    ;\n    lisa 1 100 57\n    lisa 2 98 56\n    lisa 3 91 66\n    bill 1 90 55\n    bill 2 89 51\n    bill 3 84 47\n    iris 1 88 54\n    iris 2 79 62\n    iris 3 77 43\n    ;\nrun;\n想要实现同时对 score 和 mean 两个变量的转置，如果是利用 transpose 方法。\nproc sort data=score2;\n    by name;\n    run;\n\nproc transpose data=score2 out=score2_tran1 prefix=level;\n    by name;\n    var score mean;\n    id level;\nrun;\n\ndata score2_tran2(drop=_name_);\n    merge score2_tran1(where=(_name_=\"score\") rename=(level1=score1 level2=score2 level3=score3))\n        score2_tran1(where=(_name_=\"mean\") rename=(level1=mean1 level2=mean2 level3=mean3));\n    by name;\nrun;\n可以看到没有办法一步实现，需要后面采用 merge 语句，那么利用 Do & Array 的方法。\ndata score2_tran3(drop= level score mean);\n    array ary{3,2} score1 mean1\n        score2 mean2\n        score3 mean3;\n\n    do until (last.name);\n        set score2;\n        by name;\n        ary{level,1}=score;\n        ary{level,2}=mean;\n    end;\nrun;\n可以一步实现对两个变量的转置。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Qi",
    "section": "",
    "text": "这是Qi的主页。有时候喜欢折腾下代码，也就有了这个blog。"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Going forwrad, towards your destination.",
    "section": "",
    "text": "从事生物制药行业的临床编程工作，主要使用的编程语言：\n\nSAS\nR"
  },
  {
    "objectID": "about.html#阿q",
    "href": "about.html#阿q",
    "title": "Going forwrad, towards your destination.",
    "section": "",
    "text": "从事生物制药行业的临床编程工作，主要使用的编程语言：\n\nSAS\nR"
  },
  {
    "objectID": "about.html#r-shiny-app",
    "href": "about.html#r-shiny-app",
    "title": "Going forwrad, towards your destination.",
    "section": "R shiny app:",
    "text": "R shiny app:\nAQ_TFLs_Generation"
  },
  {
    "objectID": "about.html#published-papers",
    "href": "about.html#published-papers",
    "title": "Going forwrad, towards your destination.",
    "section": "Published papers:",
    "text": "Published papers:\nGeneration of Geometric Mean Titer Plot in Immunogenicity from SAS and R"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Qi’s Blog",
    "section": "",
    "text": "SAS 比较两数据集之间的差异\n\n\n\n\n\n\n\nSAS\n\n\nSAS Advance\n\n\n\n\n\n\n\n\n\n\n\nJun 7, 2023\n\n\n\n\n\n\n  \n\n\n\n\nR 输出GMT plot\n\n\n\n\n\n\n\nR\n\n\nTidyverse\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nMay 25, 2023\n\n\n\n\n\n\n  \n\n\n\n\nSAS 绘制动态爱心\n\n\n\n\n\n\n\nSAS\n\n\n\n\n\n\n\n\n\n\n\nMay 12, 2023\n\n\n阿Q\n\n\n\n\n\n\n  \n\n\n\n\nSAS计算几何平均数（Geometric Mean）\n\n\n\n\n\n\n\nSAS\n\n\nSAS Advance\n\n\n\n\n\n\n\n\n\n\n\nMar 21, 2023\n\n\n\n\n\n\n  \n\n\n\n\nR输出AE summary by SOC and PT\n\n\n\n\n\n\n\nR\n\n\nTidyverse\n\n\nr2rtf\n\n\n\n\n\n\n\n\n\n\n\nMar 14, 2023\n\n\n\n\n\n\n  \n\n\n\n\nSAS绘制流程图\n\n\n\n\n\n\n\nSAS\n\n\nFlowChart\n\n\n\n\n\n\n\n\n\n\n\nDec 13, 2021\n\n\n\n\n\n\n  \n\n\n\n\nShiny package 绘制 COVID-19 Plot\n\n\n\n\n\n\n\nR\n\n\nTidyverse\n\n\nshiny\n\n\n\n\n\n\n\n\n\n\n\nNov 18, 2021\n\n\n\n\n\n\n  \n\n\n\n\nVS Domain\n\n\n\n\n\n\n\nCDISC\n\n\nSDTM\n\n\n\n\n\n\n\n\n\n\n\nNov 16, 2021\n\n\n\n\n\n\n  \n\n\n\n\nR绘制COVID-19新增病例趋势图\n\n\n\n\n\n\n\nR\n\n\nTidyverse\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nNov 15, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSAS SQL（二）：横向合并的逻辑\n\n\n\n\n\n\n\nSAS\n\n\nSAS Advance\n\n\nSAS SQL\n\n\n\n\n\n\n\n\n\n\n\nNov 12, 2021\n\n\n\n\n\n\n  \n\n\n\n\nAE Domain\n\n\n\n\n\n\n\nCDISC\n\n\nSDTM\n\n\n\n\n\n\n\n\n\n\n\nNov 11, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSAS SQL（一）：语法顺序与执行顺序\n\n\n\n\n\n\n\nSAS\n\n\nSAS Advance\n\n\nSAS SQL\n\n\n\n\n\n\n\n\n\n\n\nNov 10, 2021\n\n\n\n\n\n\n  \n\n\n\n\nData Step 转置\n\n\n\n\n\n\n\nSAS\n\n\nSAS Base\n\n\n\n\n\n\n\n\n\n\n\nNov 9, 2021\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Qblog/2021/ae-domain.html",
    "href": "Qblog/2021/ae-domain.html",
    "title": "AE Domain",
    "section": "",
    "text": "不良事件可以简单理解为受试者发生的任何医学事件，不一定与试验用药有关系。\n\n\n\nAETERM\nAEBODSYS / AEBODSYSCD\nAEDECOD / AEPTCD\nAESOC / AESOCCD\nAEHLGT / AEHLGTCD\nAEHLT / AEHLTCD\nAELLT / AELLTCD\n\nAETERM是EDC收集的不良事件名称，那么在实际记录过程中，对于同样的不良事件，却可能有着不同的AETERM，所以使用MedDRA编码很有必要，在后续分析过程中，也是主要采用的编码后的AEBODSYS/AEDECOD进行不良事件的分析。\n\n\n\nAE的开始结束日期时间，这类-‌-DTC的变量都需要采用ISO8601的格式，在后续分析中判断TEAE时需要关注这两个变量，特别是AESTDTC，如果刚好和试验用药同一天，最好可以收集 Time，方便与试验用药的 Time 进行比较。 AEDUR是收集的AE发生的时间区间，并不是由开始结束日期时间衍生的，那么-‌-DUR的这个规则也是适用于其他Domain的。\n\n\n\nAE的转归，考虑到受试者权益的最大化，对不良事件的随访需要随访至事件达到改善稳定的结果。值参考Termnilogy即可。\n\n\n\n相关性，比较常见的是5种分类，肯定有关，可能有关，无法判断，可能无关，肯定无关。相关性的收集尽量不要缺失，后续分析种如果相关性缺失，会采取科学严谨的原则，以“相关”进行填补。\n\n\n\n严重程度分为轻度，中度，重度 毒性等级分为1级，2级，3级，4级，5级 一般只会选择其中一个用于试验，这两个变量的收集同样尽量不要缺失，否则也会以更严谨的原则进行填补。\n\n\n\n\nAESER\nAESDTH\nAESLIFE\nAESHOSP\nAESCONG\nAESDISAB\nAESMIE\n\n严重不良事件，那么严重不良事件和重度的不良事件是完全不同的，SAE是有定义的，那么就按照定义来判断是否属于上面的哪一种SAE。而重度体现的是程度，可能SAE但是严重程度却是轻度。比如在国内医疗体制，为了报销的问题，选择住院进行治疗，但其实是无关紧要的小疾病，那么这条AE是SAE但是轻度的AE。SAE与肯定相关的AE也是完全不同的，比如受试者发生车祸意外身亡，那么这条AE是SAE但与用药无关（当然了精神类试验药物，也可能是有关的）。\n\n\n\n说到AE的编号，首先提一下AE的记录规则，一般提倡AE发生了任何变化，比如相关性改变，严重程度改变，采取的措施改变，转归改变等等，就需要重新记录一条AE。那么在分析的时候，需要对AE发生的例次进行汇总。那么对于这样的连续的几条AE在汇总例次的时候应该计为1次。这个时候AE编号的运用显得尤为重要，将多条连续的AE的标记为一个GROUP，方便后续的分析。\n\n\n\n用于标记医学特别关注的不良事件，比如在前期探索性试验中发现了某些AE发生频率较高，会对这些感兴趣的AE提前标记在CRF中。\n\n\n\nAEENRF AEENRTPT / AEENTPT\n这两组变量用于表示当AEENDTC缺失时，AE结束的大致区间。前者是和reference start date and reference end date作比较进行衍生，后者是两个变量配套使用的。 那这两组变量都是可以的，但是更推荐使用-‌-ENRTPT/-‌-ENTPT。因为前者是要求和RFSTDTC/RFENDTC作比较，那么对于未接受试验用药的受试者而言，无法衍生-‌-STRF/-‌-ENRF，索性都采取第二组变量更方便实用。\n\n\n\n这个变量大家可能会觉得奇怪，因为它不是SDTM IG中要求的变量，最终会被放到SUPPAE中，但不同的是，该变量是FDA validator rules中要求 “A treatment-emergent flag must be submitted.”，看到这段英文就知道，其实就是TEAE的flag."
  },
  {
    "objectID": "Qblog/2021/ae-domain.html#ae-adverse-events不良事件",
    "href": "Qblog/2021/ae-domain.html#ae-adverse-events不良事件",
    "title": "AE Domain",
    "section": "",
    "text": "不良事件可以简单理解为受试者发生的任何医学事件，不一定与试验用药有关系。\n\n\n\nAETERM\nAEBODSYS / AEBODSYSCD\nAEDECOD / AEPTCD\nAESOC / AESOCCD\nAEHLGT / AEHLGTCD\nAEHLT / AEHLTCD\nAELLT / AELLTCD\n\nAETERM是EDC收集的不良事件名称，那么在实际记录过程中，对于同样的不良事件，却可能有着不同的AETERM，所以使用MedDRA编码很有必要，在后续分析过程中，也是主要采用的编码后的AEBODSYS/AEDECOD进行不良事件的分析。\n\n\n\nAE的开始结束日期时间，这类-‌-DTC的变量都需要采用ISO8601的格式，在后续分析中判断TEAE时需要关注这两个变量，特别是AESTDTC，如果刚好和试验用药同一天，最好可以收集 Time，方便与试验用药的 Time 进行比较。 AEDUR是收集的AE发生的时间区间，并不是由开始结束日期时间衍生的，那么-‌-DUR的这个规则也是适用于其他Domain的。\n\n\n\nAE的转归，考虑到受试者权益的最大化，对不良事件的随访需要随访至事件达到改善稳定的结果。值参考Termnilogy即可。\n\n\n\n相关性，比较常见的是5种分类，肯定有关，可能有关，无法判断，可能无关，肯定无关。相关性的收集尽量不要缺失，后续分析种如果相关性缺失，会采取科学严谨的原则，以“相关”进行填补。\n\n\n\n严重程度分为轻度，中度，重度 毒性等级分为1级，2级，3级，4级，5级 一般只会选择其中一个用于试验，这两个变量的收集同样尽量不要缺失，否则也会以更严谨的原则进行填补。\n\n\n\n\nAESER\nAESDTH\nAESLIFE\nAESHOSP\nAESCONG\nAESDISAB\nAESMIE\n\n严重不良事件，那么严重不良事件和重度的不良事件是完全不同的，SAE是有定义的，那么就按照定义来判断是否属于上面的哪一种SAE。而重度体现的是程度，可能SAE但是严重程度却是轻度。比如在国内医疗体制，为了报销的问题，选择住院进行治疗，但其实是无关紧要的小疾病，那么这条AE是SAE但是轻度的AE。SAE与肯定相关的AE也是完全不同的，比如受试者发生车祸意外身亡，那么这条AE是SAE但与用药无关（当然了精神类试验药物，也可能是有关的）。\n\n\n\n说到AE的编号，首先提一下AE的记录规则，一般提倡AE发生了任何变化，比如相关性改变，严重程度改变，采取的措施改变，转归改变等等，就需要重新记录一条AE。那么在分析的时候，需要对AE发生的例次进行汇总。那么对于这样的连续的几条AE在汇总例次的时候应该计为1次。这个时候AE编号的运用显得尤为重要，将多条连续的AE的标记为一个GROUP，方便后续的分析。\n\n\n\n用于标记医学特别关注的不良事件，比如在前期探索性试验中发现了某些AE发生频率较高，会对这些感兴趣的AE提前标记在CRF中。\n\n\n\nAEENRF AEENRTPT / AEENTPT\n这两组变量用于表示当AEENDTC缺失时，AE结束的大致区间。前者是和reference start date and reference end date作比较进行衍生，后者是两个变量配套使用的。 那这两组变量都是可以的，但是更推荐使用-‌-ENRTPT/-‌-ENTPT。因为前者是要求和RFSTDTC/RFENDTC作比较，那么对于未接受试验用药的受试者而言，无法衍生-‌-STRF/-‌-ENRF，索性都采取第二组变量更方便实用。\n\n\n\n这个变量大家可能会觉得奇怪，因为它不是SDTM IG中要求的变量，最终会被放到SUPPAE中，但不同的是，该变量是FDA validator rules中要求 “A treatment-emergent flag must be submitted.”，看到这段英文就知道，其实就是TEAE的flag."
  },
  {
    "objectID": "Qblog/2021/r-covid-19/index.html",
    "href": "Qblog/2021/r-covid-19/index.html",
    "title": "R绘制COVID-19新增病例趋势图",
    "section": "",
    "text": "COVID-19 的病例数据来源于COVID-19 (coronavirus) by Our World in Data，并通过 OWID data 绘制一张新冠肺炎新增病例的趋势图。\n\nrm(list = ls())\noptions(digits = 4)\n\nlibrary(readxl)\ncovid &lt;- read.csv(\"owid-covid-data.csv\")\n\n为了得到每个国家对应的中文名称，还需要导入“国家和地区代码.xlsx”文件。\n\ncountry &lt;- read_excel(\"国家和地区代码.xlsx\",\n                     col_names=TRUE)\n\n选取 Brazil 作为分析对象，对数据做一些简单的处理和 mapping\n\ncovid1 &lt;- subset(covid, \n                 subset = (iso_code==\"BRA\"))\n\ncovid2 &lt;- transform(covid1, \n                    peo_vac=people_vaccinated/10000, \n                    peo_fvac=people_fully_vaccinated/10000,\n                    ana_new=new_cases,\n                    ana_dea=new_deaths,\n                    low=0\n                    )\n\ncountry1 &lt;- subset(country, \n                   subset = (X6!=\"NA\"), \n                   select = c(X2,X3,X6))\n\nlibrary(dplyr)\nanadata1 &lt;- left_join(covid2,\n                      country1,\n                      by=c(\"iso_code\"=\"X6\"))\n\n定义一个移动平均数的函数，得到移动平均值\n\nmav &lt;- function(a,n=3){\nstats::filter(a,rep(1/n,n),sides = 1)\n}\nanadata2 &lt;- transform(anadata1,\n                      mean_new=mav(ana_new,7),\n                      mean_dea=mav(ana_dea,7))\n\n利用 ggplot2 绘图\n\nlibrary(ggplot2)\ngtitle &lt;- paste(anadata2$X2,\"_\",anadata2$X3,sep='')[1]\np &lt;- ggplot(anadata2,aes(x=as.Date(date))) + \n  geom_col(aes(y=ana_new,fill=\"g_col\")) + \n  geom_line(aes(y=mean_new,color=\"g_line\"),size=1) +\n  ggtitle(gtitle) +\n  labs(x=NULL,y=NULL) +\n  scale_x_date(date_label=\"%y/%m/%d\",\n               date_breaks = \"3 month\",\n               minor_breaks = \"1 month\") +\n  scale_fill_manual(breaks = c(\"g_col\"), \n                    values = c(\"#cad5e5\"), \n                    label = c(\"New Case\")) + \n  scale_color_manual(breaks = c(\"g_line\"),\n                     values = c(\"blue\"), \n                     label = c(\"Monving Average\")) +\n  theme(plot.title =element_text(hjust = 0.5, vjust = 0.5), \n      legend.position = \"bottom\", \n      legend.title = element_blank(), \n      legend.background = element_blank()) \n\np + theme(panel.background=element_rect(fill='transparent', \n                                      color='gray'),\n        legend.key=element_rect(fill='transparent', \n                                color='transparent'))\n\n\n\n\n最后展示一下输出的plot，如上图所示。"
  },
  {
    "objectID": "Qblog/2021/sas-sql-1.html",
    "href": "Qblog/2021/sas-sql-1.html",
    "title": "SAS SQL（一）：语法顺序与执行顺序",
    "section": "",
    "text": "SAS 语言吸纳了很多其他编程语言的优势，比如 SQL procedure，在 SAS 当中也可以使用 SQL 进行增删查改。SQL procedure 一般的语法结构如下。\nPROC SQL;\n    SELECT *\n    FROM table1\n    WHERE expression\n    GROUP BY column1\n    HAVING expression\n    ORDER BY column1;\nQUIT;\n为了方便记住每个从句关键字的顺序，人们打趣的说到：” So few workers go home on time.”\nSQL procedure 的语法顺序固定的，如上code，从上至下。而执行顺序却和语法顺序不同。 FROM -‌-&gt; WHERE –&gt; GROUP BY -‌-&gt; HAVING -‌-&gt; SELECT -‌-&gt; ORDER BY 理解了执行顺序也就更容易理解 SQL 的逻辑。"
  },
  {
    "objectID": "Qblog/2021/shiny-package-covid-19-plot/index.html",
    "href": "Qblog/2021/shiny-package-covid-19-plot/index.html",
    "title": "Shiny package 绘制 COVID-19 Plot",
    "section": "",
    "text": "Shiny package 是在R中进行数据分析可视化非常著名的一个包，我们就采用这个包来展示他的一些功能。 数据来源和前期数据处理的解释，请参考上一篇文章 R绘制COVID-19新增病例趋势图 ，这里直接放上前半部分的程序。\n\n#清空工作环境\nrm(list = ls())\noptions(digits = 4)\n\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(ggplot2)\ncovid &lt;- read.csv(\"owid-covid-data.csv\")\ncountry &lt;- read_excel(\"国家和地区代码.xlsx\",\n                     col_names=TRUE)\n\ncovid1 &lt;- transform(covid, \n                    peo_vac=people_vaccinated/10000, \n                    peo_fvac=people_fully_vaccinated/10000,\n                    ana_new=new_cases,\n                    ana_dea=new_deaths,\n                    low=0)\n\ncovidvac1 &lt;- subset(covid1, subset = (peo_vac!=\"NA\"), select = c(iso_code, date, people_vaccinated_per_hundred, people_fully_vaccinated_per_hundred))\ncovidvac2 &lt;- aggregate(covidvac1, by = list(covidvac1$iso_code), FUN = last)\ncovidvac3 &lt;- rename(covidvac2, c(peo_vac1 = \"people_vaccinated_per_hundred\", peo_fvac1 = \"people_fully_vaccinated_per_hundred\"))\ncovid2 &lt;- left_join(covid1,\n                    covidvac3,\n                    by=c(\"iso_code\"=\"iso_code\", \"date\"=\"date\"))\n                    \ncountry1 &lt;- subset(country, \n                   subset = (X6!=\"NA\"), \n                   select = c(X2,X3,X6))\n\nanadata1 &lt;- left_join(covid2,\n                      country1,\n                      by=c(\"iso_code\"=\"X6\"))\n\n#定义移动平均数的函数\nmav &lt;- function(a,n){\n  stats::filter(a,rep(1/n,n),sides = 1)\n}\nanadata2 &lt;- transform(anadata1,\n                      mean_new=mav(ana_new,7),\n                      mean_dea=mav(ana_dea,7),\n                      country_code=paste(iso_code,\"_\",X2,\"_\",X3))\n\ncountryname &lt;- unique(anadata2$country_code)\n\n接下来就是 shiny 包，准备针对每个国家绘制 新增病例、死亡、接种疫苗 三个图形，UI 设计程序如下：\n\nui &lt;- fluidPage(\n  titlePanel(\"COVID-19\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"country_code\",\n                  \"Country:\",\n                  countryname),\n      radioButtons(\"ratio\", label = \"R Plot\",\n                   choices = list(\"新增病例\" = 1, \"死亡\" = 2, \"接种疫苗\" = 3),\n                   selected = 1)\n    ),\n    mainPanel(\n      h2(textOutput(\"textoutput\")),\n      plotOutput(\"plotoutput\")\n    )\n  )\n)\n\nSERVER 服务器端程序基本同上一篇的文章的 ggplot2 绘图。\n\nserver &lt;- function(input, output){\n  formulaText &lt;- reactive({\n    input$country_code\n  })\n  \n  output$textoutput &lt;- renderText({\n    formulaText()\n  })\n  \n  output$plotoutput &lt;- renderPlot({\n    plotdata &lt;- switch (input$country_code,\n        subset(anadata2,country_code==input$country_code)\n    )\n    \n    p1 &lt;- ggplot(plotdata,aes(x=as.Date(date))) + \n      {if(input$ratio == 1) geom_col(aes(y=ana_new,fill=\"g_col\"))} +\n      {if(input$ratio == 2) geom_col(aes(y=ana_dea,fill=\"g_col\"))} +\n      {if(input$ratio == 3) geom_area(aes(y=peo_vac,fill=\"g_area1\"))} +\n      {if(input$ratio == 3) geom_area(aes(y=peo_fvac,fill=\"g_area2\"))} +\n      {if(input$ratio == 1) geom_line(aes(y=mean_new,color=\"g_line\"),size=1)} +\n      {if(input$ratio == 2) geom_line(aes(y=mean_dea,color=\"g_line\"),size=1)} +\n      {if(input$ratio == 3) geom_text(aes(y=peo_vac, label=peo_vac1))} +\n      {if(input$ratio == 3) geom_text(aes(y=peo_fvac, label=peo_fvac1))} +\n      \n      labs(x=NULL,y=NULL) +\n      scale_x_date(date_label=\"%y/%m/%d\",\n                   date_breaks = \"3 month\",\n                   minor_breaks = \"1 month\") +\n      {if(input$ratio == 1) scale_fill_manual(breaks = c(\"g_col\"), \n                             values = c(\"#cad5e5\"), \n                             label = c(\"New Case\"))} + \n      {if(input$ratio == 2) scale_fill_manual(breaks = c(\"g_col\"), \n                                              values = c(\"#c5c4c5\"), \n                                              label = c(\"Death\"))} + \n      {if(input$ratio == 3) scale_fill_manual(breaks = c(\"g_area1\", \"g_area2\"), \n                                              values = c(\"#b9cfe7\", \"#8ca6ce\"), \n                                              label = c(\"Vaccined\", \"Fully Vaccined\"))} +\n      {if(input$ratio == 1) scale_color_manual(breaks = c(\"g_line\"),\n                                               values = c(\"blue\"), \n                                               label = c(\"Monving Average\"))} +\n      {if(input$ratio == 2) scale_color_manual(breaks = c(\"g_line\"),\n                                               values = c(\"#616161\"), \n                                               label = c(\"Monving Average\"))} +\n      \n      theme(plot.title =element_text(hjust = 0.5, vjust = 0.5), \n            legend.position = \"bottom\", \n            legend.title = element_blank(), \n            legend.background = element_blank()) \n    \n    p2 &lt;- p1 + theme(panel.background=element_rect(fill='transparent', \n                                                   color='gray'),\n                     legend.key=element_rect(fill='transparent', \n                                             color='transparent'))\n    p2\n  })\n}\n\n最后就是 run script。\n\n#shinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "Qblog/2023/r-ae-summary-by-soc-and-pt/index.html",
    "href": "Qblog/2023/r-ae-summary-by-soc-and-pt/index.html",
    "title": "R输出AE summary by SOC and PT",
    "section": "",
    "text": "在临床试验有关不良事件（AE）的安全性分析中，TEAE by SOC and PT的table较为常见，我们尝试用R来完成分析并输出report.\n今天重点介绍的R package: r2rtf 用于生成TFLs RTF.\n\nrm(list = ls())\nlibrary(plyr)\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(r2rtf) #generate the TFLs report\n\n读取需要用到的ADaM数据集。\n\nadsl &lt;- read_sas(\"adsl.sas7bdat\")\nadae &lt;- read_sas(\"adae.sas7bdat\")\n\n下列变量是ADSL和ADAE中需要用到的变量的label.\n\n\n\nADaM\nVariable\nLabel\n\n\n\n\nADSL/ADAE\nUSUBJID\nUnique Subject Identifier\n\n\nADSL/ADAE\nSAFFL\nSafety Population Flag\n\n\nADSL\nTRT01AN\nActual Treatment for Period 01(N)\n\n\nADAE\nTRTAN\nActual Treatment (N)\n\n\nADAE\nAEBODSYS\nBody System or Organ Class\n\n\nADAE\nAEDECOD\nDictionary-Derived Term\n\n\n\n通过ADSL计算安全性分析人群的(N = XX)\n\n#calculate big N from ADSL\nbign &lt;- rbind.fill(filter(adsl,\n                           SAFFL == \"Y\"),\n                    filter(mutate(adsl,\n                                  TRT01AN = 9),\n                           SAFFL == \"Y\")) %&gt;% \n  group_by(TRT01AN) %&gt;% \n  dplyr::summarise(bign = n_distinct(USUBJID)) %&gt;% \n  dplyr::rename(TRTAN = TRT01AN)\n\n为ADAE生成合计（Total）的分组。\n\nadae1 &lt;- rbind.fill(filter(adae,\n                           SAFFL == \"Y\"), \n                    filter(mutate(adae,\n                                  TRTAN = 9),\n                           SAFFL == \"Y\"))\n\n计算TEAE table的第一行 Any TEAE的频数。\n\n#calculate the freq for any teae\nteae_any &lt;- adae1 %&gt;% \n  group_by(TRTAN) %&gt;% \n  dplyr::summarise(n = n_distinct(USUBJID)) %&gt;% \n  ungroup() %&gt;% \n  mutate(ord = 0,\n         ord_soc = 0,\n         AEBODSYS = \"Any TEAE\")\n\n计算每个SOC的频数，需要注意SOC按照例数的倒序排序。\n\n#calculate the freq by SOC \nteae_soc &lt;- adae1 %&gt;% \n  group_by(TRTAN, AEBODSYS) %&gt;% \n  dplyr::summarise(n = n_distinct(USUBJID)) %&gt;% \n  ungroup()\n\n`summarise()` has grouped output by 'TRTAN'. You can override using the\n`.groups` argument.\n\nteae_soc_ord &lt;- teae_soc %&gt;% \n  filter(TRTAN == 9) %&gt;% \n  arrange(desc(n), AEBODSYS) %&gt;% \n  mutate(ord_soc = row_number())\n\nteae_soc1 &lt;- left_join(teae_soc, \n                       select(teae_soc_ord, AEBODSYS, ord_soc),\n                       by = c(\"AEBODSYS\")) %&gt;% \n  mutate(ord = 1)\n\n计算每个SOC and PT的频数，同样需要注意按照SOC，PT的倒序排序。\n\n#calculate the freq by SOC and PT \nteae_pt &lt;- adae1 %&gt;% \n  group_by(TRTAN, AEBODSYS, AEDECOD) %&gt;% \n  dplyr::summarise(n = n_distinct(USUBJID)) %&gt;% \n  ungroup()\n\n`summarise()` has grouped output by 'TRTAN', 'AEBODSYS'. You can override using\nthe `.groups` argument.\n\nteae_pt_ord &lt;- teae_pt %&gt;% \n  filter(TRTAN == 9) %&gt;% \n  left_join(select(teae_soc_ord,AEBODSYS, ord_soc),\n            by = c(\"AEBODSYS\")) %&gt;% \n  arrange(ord_soc, desc(n), AEDECOD) %&gt;% \n  mutate(ord_pt = row_number())\n\n\nteae_pt1 &lt;- left_join(teae_pt,\n                      select(teae_pt_ord, AEBODSYS, AEDECOD, ord_soc, ord_pt),\n                      by = c(\"AEBODSYS\", \"AEDECOD\")) %&gt;% \n  mutate(ord = 2) %&gt;% \n  arrange(ord_soc, ord_pt)\n\n合并形成最终的数据集，并计算百分比。\n\n#combine SOC and PT\nfinal &lt;- rbind.fill(teae_any, teae_soc1, teae_pt1) %&gt;% \n  left_join(bign,\n            by = c(\"TRTAN\")) %&gt;% \n  mutate(percent = round(100*n/bign, 1),\n         col = str_c(as.character(n),\n               \" (\",\n               as.character(percent),\n               \")\"),\n         item = case_when(is.na(AEDECOD) ~ AEBODSYS,\n                          TRUE ~ str_c(\"  \", AEDECOD))) %&gt;% \n  pivot_wider(id_cols = c(item, ord, ord_soc, ord_pt),\n              names_from = TRTAN,\n              values_from = col,\n              names_prefix = \"col\",\n              values_fill = \"0\") %&gt;% \n  arrange(ord_soc, ord, ord_pt) %&gt;% \n  group_split(ord_soc) %&gt;% \n  map_dfr(~add_row(.x, .after = Inf)) %&gt;% \n  select(item, col1, col2, col9)\n\n由于report中需要输出(N = XX)，提前做一个object.\n\ncolhead_bign &lt;- bign %&gt;% \n  mutate(header = str_c(\"(N = \", as.character(bign), \")\"))\n\ncolhead_bign &lt;- str_c(\"Systerm Organ Class\",\n        str_c(pull(colhead_bign, header), collapse = \"|\"), sep = \"|\")\n\n通过r2rtf 定制table的样式，并输出RTF文件。\n\n#TFLs report\nreport &lt;- final %&gt;% \n  rtf_page(nrow = 25,\n           orientation = \"landscape\",\n           border_first = \"single\",\n           border_last = \"single\") %&gt;% \n  rtf_title(\n    title = c(\n      \"Table 14.3.3.1\",\n      \"Summary of TEAEs by System Organ Class and Preferred Term\",\n      \"Safety Set\"\n    ),\n    text_font_size = 9,\n    text_font = 4  #Arial\n  ) %&gt;% \n  rtf_footnote(\n    footnote = c(\n      \"Abbreviations: TEAE = Treatment-emergent adverse event.\",\n      \"Note: MedDRA Version 25.1.\"\n    ),\n    text_font = 4, #Arial\n    as_table = FALSE\n  ) %&gt;% \n  rtf_colheader(\n    colheader = \" | Arm A | Arm B | Total\",\n    col_rel_width = c(4, rep(1, 3)),\n    text_justification = c(\"l\", rep(\"c\", 3)),\n    border_left = NULL,\n    border_right = NULL,\n    text_font = 4\n  ) %&gt;% \n  rtf_colheader(\n    colheader = colhead_bign,\n    col_rel_width = c(4, rep(1, 3)),\n    text_justification = c(\"l\", rep(\"c\", 3)),\n    border_top = NULL,\n    border_left = NULL,\n    border_right = NULL,\n    text_font = 4\n  ) %&gt;% \n  rtf_colheader(\n    colheader = \"{^\\\\s} {^\\\\s} Preferred Term | n (%) | n (%) | n (%)\",\n    col_rel_width = c( 4, rep(1, 3)),\n    text_justification = c(\"l\", rep(\"c\", 3)),\n    text_indent_first = 2,\n    border_top = NULL,\n    border_left = NULL,\n    border_right = NULL,\n    text_font = 4\n  ) %&gt;% \n  rtf_body(text_justification = c(\"l\", rep(\"c\", 3)),\n           col_rel_width = c( 4, rep(1, 3)),\n           text_font = 4,\n           border_left = NULL,\n           border_right = NULL) %&gt;%\n  rtf_source(\n    source = \"[Source: Listing 16.2.7 Adverse Event]\",\n    text_justification = \"l\",\n    text_font = 4,\n    as_table = FALSE\n  ) %&gt;% \n  rtf_encode() %&gt;% \n  write_rtf(\"t_14_3_3_1.rtf\")\n\n最后是成果展示了。\n\n\n\nae_table"
  },
  {
    "objectID": "Qblog/2023/sas-geometric-mean.html",
    "href": "Qblog/2023/sas-geometric-mean.html",
    "title": "SAS计算几何平均数（Geometric Mean）",
    "section": "",
    "text": "在一组数据满足对数正态分布时，我们需要用到几何平均数来评估这组数据的”中心”，计算方法为这组数据的连乘积开项数次方根，计算公式如下。\n\\[G_n = \\sqrt[n]{\\prod_{i=1}^n x_i} = \\sqrt[n]{x_1 x_2 x_3 \\cdots x_n}\\]\n我们这里介绍几种方法供大家参考。\n\n\n*** 1. 对数据列（aval）求对数 ***\n    logaval = log(aval);\n*** 2. proc means 计算logaval的均值 ***\nproc means data=adis n mean lclm uclm noprint;\n    by trtan avisitn;\n    var logaval;\n    output out=gmt1 n=n mean=mean lclm=lclm uclm=uclm;\nrun;\n*** 3. 10的次幂取回， 10**mean ***\n\n\n\n*** 1. 对数据列（aval）求对数 ***\nlogaval = log(aval);\n*** 2. 采用proc sql衍生几何均值***\nproc sql noprint;\n    create table gmt2 as select distinct trtan, avisitn, exp(mean(logaval)) as gmean from adis group by trtan, avisitn;\nquit;\n\n\n\n*** proc ttest, dist 选项指定为lognormal， 即对数正态分布 ***;\nods output ConfLimits=gmt3;\nproc ttest data=adis dist=lognormal;\n    by trtpn avisitn;\n    var aval;\nrun;\n\n\n\n*** proc surveymeans, 添加geomean gmclm等keywords ***;\nods output GeometricMeans=gmt4;\nproc surveymeans data=adis geomean gmclm ;\n    by trtpn avisitn;\n    var aval;\n    run;\n\n\n\n*** proc univariate, 输出数据集中取_GEOMEAN_ ***;\nproc univariate data=adis outtable=DescStats noprint;\n    by trtpn avisitn;\n    var aval;\nrun;"
  },
  {
    "objectID": "Qblog/2023/sas-geometric-mean.html#几何均值",
    "href": "Qblog/2023/sas-geometric-mean.html#几何均值",
    "title": "SAS计算几何平均数（Geometric Mean）",
    "section": "",
    "text": "在一组数据满足对数正态分布时，我们需要用到几何平均数来评估这组数据的”中心”，计算方法为这组数据的连乘积开项数次方根，计算公式如下。\n\\[G_n = \\sqrt[n]{\\prod_{i=1}^n x_i} = \\sqrt[n]{x_1 x_2 x_3 \\cdots x_n}\\]\n我们这里介绍几种方法供大家参考。\n\n\n*** 1. 对数据列（aval）求对数 ***\n    logaval = log(aval);\n*** 2. proc means 计算logaval的均值 ***\nproc means data=adis n mean lclm uclm noprint;\n    by trtan avisitn;\n    var logaval;\n    output out=gmt1 n=n mean=mean lclm=lclm uclm=uclm;\nrun;\n*** 3. 10的次幂取回， 10**mean ***\n\n\n\n*** 1. 对数据列（aval）求对数 ***\nlogaval = log(aval);\n*** 2. 采用proc sql衍生几何均值***\nproc sql noprint;\n    create table gmt2 as select distinct trtan, avisitn, exp(mean(logaval)) as gmean from adis group by trtan, avisitn;\nquit;\n\n\n\n*** proc ttest, dist 选项指定为lognormal， 即对数正态分布 ***;\nods output ConfLimits=gmt3;\nproc ttest data=adis dist=lognormal;\n    by trtpn avisitn;\n    var aval;\nrun;\n\n\n\n*** proc surveymeans, 添加geomean gmclm等keywords ***;\nods output GeometricMeans=gmt4;\nproc surveymeans data=adis geomean gmclm ;\n    by trtpn avisitn;\n    var aval;\n    run;\n\n\n\n*** proc univariate, 输出数据集中取_GEOMEAN_ ***;\nproc univariate data=adis outtable=DescStats noprint;\n    by trtpn avisitn;\n    var aval;\nrun;"
  },
  {
    "objectID": "Qblog/2023/sas-sql-compare/index.html",
    "href": "Qblog/2023/sas-sql-compare/index.html",
    "title": "SAS 比较两数据集之间的差异",
    "section": "",
    "text": "Dataset Preparation\n我们直接使用熟悉的SASHELP.CLASS作为测试数据集。\ndata class1;\n  set sashelp.class;\n  if _n_&lt;=5;\nrun;\nproc print;run;\n\ndata class2;\n  set sashelp.class;\n  if _n_&lt;=3 or _n_ in (6 7 8);\nrun;\nproc print;run;\n如下图所示，红色部分为CLASS1和CLASS2两个数据集之间相同的观测，蓝色部分为两者之间不同的观测。\n\n\n\nsas-sql-compare\n\n\n\n\n方法一：DATA STEP\n在DATA STEP中，如果想要得到CLASS2相比CLASS1有更新的观测，可以通过：\nproc sort data=class1;by _all_;run;\nproc sort data=class2;by _all_;run;\n\ndata update_row;\n    merge class1(in=a) class2(in=b);\n    by _all_;\n    if b and ^a;\nrun;\nproc print;run;\n如果想要得到两个数据集之间共同的观测，也很简单：\ndata common_row;\n    merge class1(in=a) class2(in=b);\n    by _all_;\n    if a and b;\nrun;\nproc print;run;\n\n\n方法二：PROC SQL\n那么在PROC SQL中该如何实现上述的功能呢？常规方法的比如inner join，left join就可以实现， 而这里的方法是需要介绍两个operator，EXCEPT与INTERSECT。\nproc sql;\n    select * from class2\n        except select * from class1;\nquit;\n\nproc sql;\n    select * from class2\n        intersect select * from class1;\nquit;\n\n\n方法三：SAS Hash\n使用HASH对象来找出来两者之间的异同。\ndata update_row2;\n    if _n_=1 then do;\n        declare hash h(dataset:\"class1\", ordered:\"yes\");\n        h.defineKey(all:\"yes\");\n        h.defineData(all:\"yes\");\n        h.defineDone();\n    end;\n    set class2;\n    if h.find() ne 0;\nrun;\n\ndata common_row2;\n    if _n_=1 then do;\n        declare hash h(dataset:\"class1\", ordered:\"yes\");\n        h.defineKey(all:\"yes\");\n        h.defineData(all:\"yes\");\n        h.defineDone();\n    end;\n    set class2;\n    if h.find() = 0;\nrun;"
  }
]